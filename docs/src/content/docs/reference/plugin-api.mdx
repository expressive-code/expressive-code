---
# WARNING: Do not edit this file directly, your changes will be overwritten!
# This file is auto-generated from a template inside "scripts/typedoc/templates".
title: Plugin API
---

import PropertySignature from '@components/PropertySignature.astro'

## ExpressiveCodePlugin

An interface that defines an Expressive Code plugin. To add a custom plugin, you pass an object matching this interface into the `plugins` array property of the engine configuration.

### Properties

#### name

<PropertySignature>
- Type: `string`
</PropertySignature>

The display name of the plugin. This is the only required property. It is used by the engine to display messages concerning the plugin, e.g. when it encounters an error.

#### annotationCommentHandlers?

<PropertySignature>
- Type: [`AnnotationCommentHandler`](/reference/plugin-api/#annotationcommenthandler)[]
</PropertySignature>

An array of annotation comment handlers provided by the plugin.

To add support for annotation comments, add one or more annotation comment handlers to this array. These handlers map annotation tag names to settings that define how the annotations should be processed and rendered.

Annotation comment handlers can be used to enrich the presentation of code blocks with additional information, such as highlights, notes, expected output, warnings, error messages, or links to external resources.

#### baseStyles?

<PropertySignature>
- Type: `string` \| [`BaseStylesResolverFn`](/reference/plugin-api/#basestylesresolverfn)
</PropertySignature>

The CSS styles that should be added to every page containing code blocks.

All styles are scoped to Expressive Code by default, so they will not affect the rest of the page. SASS-like nesting is supported. If you want to add global styles, you can use the `@at-root` rule or target `:root`, `html` or `body` in your selectors.

The engine's `getBaseStyles` function goes through all registered plugins and collects their base styles.

If you provide a function instead of a string, it is called with an object argument of type [ResolverContext](/reference/plugin-api/#resolvercontext), and is expected to return a string or a string promise.

The calling code must take care of actually adding the collected styles to the page. For example, it could create a site-wide CSS stylesheet from the base styles and insert a link to it, or it could insert the base styles into a `<style>` element.

#### hooks?

<PropertySignature>
- Type: [`ExpressiveCodePluginHooks`](/reference/plugin-hooks/)
</PropertySignature>

A set of functions that should be called by the engine at specific points in the rendering process. See [ExpressiveCodePluginHooks](/reference/plugin-hooks/) for a list of available hooks.

#### jsModules?

<PropertySignature>
- Type: `string`[] \| [`JsModulesResolverFn`](/reference/plugin-api/#jsmodulesresolverfn)
</PropertySignature>

JavaScript modules (pure code without any wrapping `script` tags) that should be added to every page containing code blocks.

The engine's `getJsModules` function goes through all registered plugins, collects their JS modules and deduplicates them.

If you provide a function instead of a string, it is called with an object argument of type [ResolverContext](/reference/plugin-api/#resolvercontext), and is expected to return a string or a string promise.

The calling code must take care of actually adding the collected scripts to the page. For example, it could create site-wide JavaScript files from the returned modules and refer to them in a script tag with `type="module"`, or it could insert them into inline `<script type="module">` elements.

#### styleSettings?

<PropertySignature>
- Type: [`PluginStyleSettings`](/reference/plugin-api/#pluginstylesettings)
</PropertySignature>

An instance of `PluginStyleSettings` that is used to define the plugin's CSS variables.

## PluginStyleSettings

Represents a strongly typed set of style settings provided by a plugin (or core).

The constructor expects an object with a `defaultSettings` property. This property must contain the default values for all settings and will be made available as a public instance property. Allowed default value types are plain values (e.g. strings), an array of two values to provide a dark and light variant, or resolver functions that return one of these types.

If you are writing a plugin that provides style overrides, please merge your style overrides into the `StyleOverrides` interface declaration provided by the `@expressive-code/core` module. You can see an example of this below.

As a plugin author, you should also assign an instance of this class to your plugin's
`styleSettings` property. This allows the engine to automatically declare CSS variables for your style settings in all theme variants defined in the config.

To consume the CSS variables in your plugin's `baseStyles` or anywhere else, see the
cssVar method to get a CSS variable reference to any style setting.

If CSS variables should not be generated for some of your style settings, you can exclude them using the `cssVarExclusions` property of the object passed to the constructor.

### Example

```ts
// When using TypeScript: Declare the types of your style settings
interface FramesStyleSettings {
  fontFamily: string
  fontSize: string
  minContrast: string
  titleBarForeground: string
}

// When using TypeScript: Merge your style settings into the core module's `StyleSettings`
declare module '@expressive-code/core' {
  export interface StyleSettings {
    frames: FramesStyleSettings
  }
}

const framesStyleSettings = new PluginStyleSettings({
  defaultValues: {
    frames: {
      fontFamily: 'sans-serif',
      fontSize: '1rem',
      minContrast: '5',
      titleBarForeground: ({ theme }) => theme.colors['editor.foreground'],
    }
  },
  cssVarExclusions: ['frames.minContrast'],
})

// ↓↓↓

framesStyleSettings.defaultValues.frames.fontFamily         // 'sans-serif'
framesStyleSettings.defaultValues.frames.fontSize           // '1rem'
framesStyleSettings.defaultValues.frames.minContrast        // '5'
framesStyleSettings.defaultValues.frames.titleBarForeground // ({ theme }) => theme.colors['editor.foreground']
```

### Constructors

#### new PluginStyleSettings(options)

- <code class="function-signature">**new PluginStyleSettings**(options): [PluginStyleSettings](/reference/plugin-api/#pluginstylesettings)</code>

##### Arguments

| Parameter | Type |
| :------ | :------ |
| `options` | `Object` |
| `options.defaultValues` | `Partial`\<[`UnresolvedStyleSettings`](/reference/plugin-api/#unresolvedstylesettings)\> |
| `options.cssVarExclusions`? | [`StyleSettingPath`](/reference/plugin-api/#stylesettingpath)[] |

### Properties

#### cssVarExclusions

<PropertySignature>
- Type: **readonly** [`StyleSettingPath`](/reference/plugin-api/#stylesettingpath)[]
</PropertySignature>

#### defaultValues

<PropertySignature>
- Type: **readonly** `Partial`\<[`UnresolvedStyleSettings`](/reference/plugin-api/#unresolvedstylesettings)\>
</PropertySignature>

## AttachedPluginData

A class that allows plugins to attach custom data to objects like code blocks, and to optionally allow external access to this data in a type-safe manner.

### Usage example

```ts
// pluginDataExample.ts
import { AttachedPluginData, ExpressiveCodePlugin } from '@expressive-code/core'

export function pluginDataExample(): ExpressiveCodePlugin {
  return {
    name: 'AttachedPluginDataExample',
    hooks: {
      preprocessMetadata: ({ codeBlock }) => {
        // Get a reference to the block's data object
        const blockData = pluginFramesData.getOrCreateFor(codeBlock)

        // Example: Store the meta string in the data object
        // and remove it from the block
        blockData.extractedMeta = codeBlock.meta
        codeBlock.meta = ''
      },
      postprocessRenderedBlock: ({ codeBlock }) => {
        // Try to retrieve the stored title from the block's data object
        const blockData = pluginFramesData.getOrCreateFor(codeBlock)

        // Log the extracted data
        console.dir(blockData)
      },
    },
  }
}

// Define the data object type
export interface PluginFramesData {
  extractedMeta?: string
}

// Create a singleton instance that allows attaching this type of data
// to any object and to retrieve it later.
// Note: Exporting is optional. This can be useful if multiple plugins
//       need to work together.
export const pluginFramesData = new AttachedPluginData<PluginFramesData>(
  // This function initializes the attached data
  // in case nothing was attached to an object yet
  () => ({})
)
```

### Type parameters

| Parameter |
| :------ |
| `PluginDataType` |

### Constructors

#### new AttachedPluginData(getInitialValueFn)

- <code class="function-signature">**new AttachedPluginData**\<PluginDataType\>(getInitialValueFn): [AttachedPluginData](/reference/plugin-api/#attachedplugindata)\<PluginDataType\></code>

##### Arguments

| Parameter | Type |
| :------ | :------ |
| `getInitialValueFn` | () => `PluginDataType` |

### Methods

#### getOrCreateFor()

- <code class="function-signature">**getOrCreateFor**(target): PluginDataType</code>

##### Arguments

| Parameter | Type |
| :------ | :------ |
| `target` | `PluginDataTarget` |

#### setFor()

- <code class="function-signature">**setFor**(target, data): void</code>

##### Arguments

| Parameter | Type |
| :------ | :------ |
| `target` | `PluginDataTarget` |
| `data` | `PluginDataType` |

## Referenced types

### AnnotationCommentHandler

<PropertySignature>
- Type: `Object`
</PropertySignature>

An object that you can add to the [`annotationCommentHandlers`](#annotationcommenthandlers) array property of an [`ExpressiveCodePlugin`](#expressivecodeplugin).

A handler maps annotation tag names to settings that define how annotations using these tag names should be processed and rendered.

Annotation comment handlers can be used to enrich the presentation of code blocks with additional information, such as highlights, notes, expected output, warnings, error messages, or links to external resources.

#### Object properties

<dl class="type-declaration-list">
<dt>codeBlock</dt>
<dd>
<PropertySignature>
- Type: [`AddClasses`](/reference/plugin-api/#addclasses) \| `undefined`
</PropertySignature>
Allows defining actions to perform on the parent code block when an annotation comment using one of the tag names registered by this handler is encountered.
</dd>
<dt>custom</dt>
<dd>
<PropertySignature>
- Type: (`context`) => `void`
</PropertySignature>
</dd>
<dt>tagNames</dt>
<dd>
<PropertySignature>
- Type: `string`[]
</PropertySignature>
The annotation tag names that this handler should process.

By default, tag names must be unique across all annotation comment handlers, and attempting to register a handler for an existing tag name will throw an error. To change this, set the `overrideExisting` property to `true`.
</dd>
<dt>contents</dt>
<dd>
<PropertySignature>
- Type: [`ContentOptions`](/reference/plugin-api/#contentoptions) & [`WrapWith`](/reference/plugin-api/#wrapwith) & [`CopyBehavior`](/reference/plugin-api/#copybehavior)
</PropertySignature>
Defines how to render any contents following the annotation tag.

If this is not set, annotation contents are removed from the code and not rendered.
</dd>
<dt>fullLineTargets</dt>
<dd>
<PropertySignature>
- Type: [`AddClasses`](/reference/plugin-api/#addclasses) & [`CopyBehavior`](/reference/plugin-api/#copybehavior)
</PropertySignature>
Allows defining actions to perform on full-line targets of annotation comments in the code.

For example, the annotation comment `// [!highlight:3]` targets up to 3 lines of code, and an annotation comment handler for the tag name `highlight` would perform the actions defined in this property on the target lines.
</dd>
<dt>inlineTargets</dt>
<dd>
<PropertySignature>
- Type: [`WrapWith`](/reference/plugin-api/#wrapwith) & [`CopyBehavior`](/reference/plugin-api/#copybehavior)
</PropertySignature>
Allows defining actions to perform on inline targets of annotation comments in the code (e.g. search term or regular expression matches, but not full lines).

For example, the annotation comment `// [!highlight:search-term:3]` targets up to 3 matches of `search-term` in the code, and an annotation comment handler for the tag name `highlight` would perform the actions defined in this property on the targets.
</dd>
<dt>overrideExisting</dt>
<dd>
<PropertySignature>
- Type: `boolean`
</PropertySignature>
Whether to allow overriding existing tag names with this handler.

</dd>
</dl>

#### Handler setting types

##### AddClasses

<dl class="type-declaration-list">
<dt>addClasses</dt>
<dd>
<PropertySignature>
- Type: `string`[]
</PropertySignature>
</dd>
</dl>

##### ContentOptions

<dl class="type-declaration-list">
<dt>output</dt>
<dd>
<PropertySignature>
- Type: `"none"` \| `"inlineAtAnnotation"` \| `"inlineAtEndOfTargetLine"` \| `"betweenLinesAtAnnotation"` \| `"betweenLinesAboveTarget"` \| `"betweenLinesBelowTarget"`
</PropertySignature>
How to output any contents following the annotation tag.

The default behavior is to remove the entire annotation (tag & contents) from the code and not include it in the rendered output. To change this and render the contents, set this option to a value other than `none`.

Available values:
- `none` (default): Annotation contents are removed from the code and not rendered.
- `inlineAtAnnotation`: Annotation contents are rendered in the line and column where the annotation is located.
- `inlineAtEndOfTargetLine`: Annotation contents are rendered at the end of the line where the annotation is located.
- `betweenLinesAtAnnotation`: The code lines are split at the annotation line, and the contents are rendered between the two parts.
- `betweenLinesAboveTarget`: The code lines are split above the first target, and the contents are rendered between the two parts.
- `betweenLinesBelowTarget`: The code lines are split below the last target, and the contents are rendered between the two parts.

To further influence how the contents are rendered, see the options
`renderAs`, `addInlineStyle` and `wrapWith`.
</dd>
<dt>renderAs</dt>
<dd>
<PropertySignature>
- Type: `"inline-markdown"` \| `"plaintext"`
</PropertySignature>
Available renderers:
- `inline-markdown` (default): The contents are rendered with limited support for inline Markdown formatting.
  - The following Markdown features are supported:
    - `*italic*`, `**bold**`, including combinations like `***bold** & italic*`
  - When `output` is set to an `inline` option, contents are rendered as a single line, with support for basic inline Markdown formatting and links.
  - When `output` is set to a `betweenLines` option, contents are rendered as a Markdown document, with support for headings, lists, code blocks, and more.
- `plaintext`: The contents are rendered as-is, without any special formatting applied.
  - Single line breaks are collapsed to a single space.
  - When `output` is set to a `betweenLines` option, empty lines start a new paragraph.
</dd>
</dl>

##### CopyBehavior

<dl class="type-declaration-list">
<dt>stripFromCode</dt>
<dd>
<PropertySignature>
- Type: `boolean`
</PropertySignature>
</dd>
</dl>

##### WrapWith

<dl class="type-declaration-list">
<dt>wrapWith</dt>
<dd>
<PropertySignature>
- Type: `string`
</PropertySignature>
</dd>
</dl>

### BaseStylesResolverFn

<PropertySignature>
- Type: (`context`) => `string` \| `Promise`\<`string`\>
</PropertySignature>

A function that you can assign to the [`baseStyles`](#basestyles) property of an [`ExpressiveCodePlugin`](#expressivecodeplugin).

The engine will call it when going through all registered plugins and collecting their base styles.

:::tip
You can use this to include CSS variables generated from any style settings, including your own [`PluginStyleSettings`](#pluginstylesettings), into your plugin's base styles.

The function will be called with a `context` argument of type [`ResolverContext`](#resolvercontext) that provides helpful functions like `cssVar` to access any generated CSS variable by its style setting path.
:::

#### Arguments

| Parameter | Type |
| :------ | :------ |
| `context` | [`ResolverContext`](/reference/plugin-api/#resolvercontext) |

### JsModulesResolverFn

<PropertySignature>
- Type: (`context`) => `string`[] \| `Promise`\<`string`[]\>
</PropertySignature>

A function that you can assign to the [`jsModules`](#jsmodules) property of an [`ExpressiveCodePlugin`](#expressivecodeplugin).

The engine will call it when going through all registered plugins and collecting their JS modules.

#### Arguments

| Parameter | Type |
| :------ | :------ |
| `context` | [`ResolverContext`](/reference/plugin-api/#resolvercontext) |

### ResolverContext

<PropertySignature>
- Type: `Object`
</PropertySignature>

A context object that the engine passes to most hook functions.

It provides access to theme-dependent CSS variables, all resolved style variants based on the configured themes and settings, and the config-dependent wrapper class name.

#### Object properties

<dl class="type-declaration-list">
<dt>cssVar</dt>
<dd>
<PropertySignature>
- Type: (`styleSetting`, `fallbackValue`?) => `string`
</PropertySignature>
</dd>
<dt>cssVarName</dt>
<dd>
<PropertySignature>
- Type: (`styleSetting`) => `string`
</PropertySignature>
</dd>
<dt>styleVariants</dt>
<dd>
<PropertySignature>
- Type: [`StyleVariant`](/reference/plugin-api/#stylevariant)[]
</PropertySignature>
</dd>
</dl>

### ResolvedStyleSettingsByPath

<PropertySignature>
- Type: `Map`\<[`StyleSettingPath`](/reference/plugin-api/#stylesettingpath), `string`\>
</PropertySignature>

### StyleResolverFn

<PropertySignature>
- Type: (`context`) => [`StyleValueOrValues`](/reference/plugin-api/#stylevalueorvalues)
</PropertySignature>

A function that resolves a single style setting to a [StyleValueOrValues](/reference/plugin-api/#stylevalueorvalues).

You can assign this to any style setting to dynamically generate style values based on the current theme.

This function is called once for each style variant in the engine's `styleVariants` array, which includes one entry per theme in the engine's `themes` configuration option.

#### Arguments

| Parameter | Type | Description |
| :------ | :------ | :------ |
| `context` | `Object` | - |
| `context.resolveSetting` | (`settingPath`) => `string` | - |
| `context.styleVariantIndex` | `number` | The index in the engine's `styleVariants` array that's currently being resolved. |
| `context.theme` | [`ExpressiveCodeTheme`](/reference/core-api/#expressivecodetheme) | - |

### StyleSettingPath

<PropertySignature>
- Type: `FlattenKeys`\<`StyleSettings`\>
</PropertySignature>

### StyleValueOrValues

<PropertySignature>
- Type: `string` \| \[`string`, `string`\]
</PropertySignature>

The value of a single style setting. You can either set it to a string, or an array of two strings.

If you use the array form, the first value will be used for dark themes, and the second value for light themes.

### StyleVariant

<PropertySignature>
- Type: `Object`
</PropertySignature>

#### Object properties

<dl class="type-declaration-list">
<dt>cssVarDeclarations</dt>
<dd>
<PropertySignature>
- Type: `Map`\<`string`, `string`\>
</PropertySignature>
</dd>
<dt>resolvedStyleSettings</dt>
<dd>
<PropertySignature>
- Type: [`ResolvedStyleSettingsByPath`](/reference/plugin-api/#resolvedstylesettingsbypath)
</PropertySignature>
</dd>
<dt>theme</dt>
<dd>
<PropertySignature>
- Type: [`ExpressiveCodeTheme`](/reference/core-api/#expressivecodetheme)
</PropertySignature>
</dd>
</dl>

### UnresolvedPluginStyleSettings

<PropertySignature>
- Type: `{ [SettingName in keyof T]: UnresolvedStyleValue }`
</PropertySignature>

#### Type parameters

| Parameter |
| :------ |
| `T` |

### UnresolvedStyleValue

<PropertySignature>
- Type: [`StyleValueOrValues`](/reference/plugin-api/#stylevalueorvalues) \| [`StyleResolverFn`](/reference/plugin-api/#styleresolverfn)
</PropertySignature>

This is the value type for all style overrides. It allows either static style values or a resolver function.

### UnresolvedStyleSettings

<PropertySignature>
- Type: `{ [K in keyof StyleSettings]: StyleSettings[K] extends object ? UnresolvedPluginStyleSettings<StyleSettings[K]> : UnresolvedStyleValue }`
</PropertySignature>
