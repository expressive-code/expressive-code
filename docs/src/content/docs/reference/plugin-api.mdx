---
# WARNING: Do not edit this file directly, your changes will be overwritten!
# This file is auto-generated from a template inside "scripts/typedoc/templates".
title: Plugin API
---

## ExpressiveCodePlugin

An interface that defines an Expressive Code plugin. To add a custom plugin, you pass an object matching this interface into the `plugins` array property of the engine configuration.

### Properties

#### name

- Type: `string`

The display name of the plugin. This is the only required property. It is used by the engine to display messages concerning the plugin, e.g. when it encounters an error.

#### baseStyles?

- Type: `string` \| [`BaseStylesResolverFn`](/api/expressive-code/core/type-aliases/basestylesresolverfn/)

The CSS styles that should be added to every page containing code blocks.

All styles are scoped to Expressive Code by default, so they will not affect the rest of the page. SASS-like nesting is supported. If you want to add global styles, you can use the `@at-root` rule or target `:root`, `html` or `body` in your selectors.

The engine's `getBaseStyles` function goes through all registered plugins and collects their base styles.

If you provide a function instead of a string, it is called with an object argument of type [ResolverContext](/api/expressive-code/core/type-aliases/resolvercontext/), and is expected to return a string or a string promise.

The calling code must take care of actually adding the collected styles to the page. For example, it could create a site-wide CSS stylesheet from the base styles and insert a link to it, or it could insert the base styles into a `<style>` element.

#### hooks?

- Type: [`ExpressiveCodePluginHooks`](/api/expressive-code/core/interfaces/expressivecodepluginhooks/)

A set of functions that should be called by the engine at specific points in the rendering process. See [ExpressiveCodePluginHooks](/api/expressive-code/core/interfaces/expressivecodepluginhooks/) for a list of available hooks.

#### jsModules?

- Type: `string`[] \| [`JsModulesResolverFn`](/api/expressive-code/core/type-aliases/jsmodulesresolverfn/)

JavaScript modules (pure code without any wrapping `script` tags) that should be added to every page containing code blocks.

The engine's `getJsModules` function goes through all registered plugins, collects their JS modules and deduplicates them.

If you provide a function instead of a string, it is called with an object argument of type [ResolverContext](/api/expressive-code/core/type-aliases/resolvercontext/), and is expected to return a string or a string promise.

The calling code must take care of actually adding the collected scripts to the page. For example, it could create site-wide JavaScript files from the returned modules and refer to them in a script tag with `type="module"`, or it could insert them into inline `<script type="module">` elements.

#### styleSettings?

- Type: [`PluginStyleSettings`](/api/expressive-code/core/classes/pluginstylesettings/)

An instance of `PluginStyleSettings` that is used to define the plugin's CSS variables.


## AttachedPluginData

A class that allows plugins to attach custom data to objects like code blocks, and to optionally allow external access to this data in a type-safe manner.

### Usage example

```ts
// pluginDataExample.ts
import { AttachedPluginData, ExpressiveCodePlugin } from '@expressive-code/core'

export function pluginDataExample(): ExpressiveCodePlugin {
  return {
    name: 'AttachedPluginDataExample',
    hooks: {
      preprocessMetadata: ({ codeBlock }) => {
        // Get a reference to the block's data object
        const blockData = pluginFramesData.getOrCreateFor(codeBlock)

        // Example: Store the meta string in the data object
        // and remove it from the block
        blockData.extractedMeta = codeBlock.meta
        codeBlock.meta = ''
      },
      postprocessRenderedBlock: ({ codeBlock }) => {
        // Try to retrieve the stored title from the block's data object
        const blockData = pluginFramesData.getOrCreateFor(codeBlock)

        // Log the extracted data
        console.dir(blockData)
      },
    },
  }
}

// Define the data object type
export interface PluginFramesData {
  extractedMeta?: string
}

// Create a singleton instance that allows attaching this type of data
// to any object and to retrieve it later.
// Note: Exporting is optional. This can be useful if multiple plugins
//       need to work together.
export const pluginFramesData = new AttachedPluginData<PluginFramesData>(
  // This function initializes the attached data
  // in case nothing was attached to an object yet
  () => ({})
)
```

### Type parameters

| Parameter |
| :------ |
| `PluginDataType` |

### Constructors

#### new AttachedPluginData(getInitialValueFn)

- <code class="function-signature">**new AttachedPluginData**\<PluginDataType\>(getInitialValueFn): [AttachedPluginData](/api/expressive-code/core/classes/attachedplugindata/)\<PluginDataType\></code>

##### Arguments

| Parameter | Type |
| :------ | :------ |
| `getInitialValueFn` | () => `PluginDataType` |

### Methods

#### getOrCreateFor()

- <code class="function-signature">**getOrCreateFor**(target): PluginDataType</code>

##### Arguments

| Parameter | Type |
| :------ | :------ |
| `target` | [`PluginDataTarget`](/api/expressive-code/core/type-aliases/plugindatatarget/) |

#### setFor()

- <code class="function-signature">**setFor**(target, data): void</code>

##### Arguments

| Parameter | Type |
| :------ | :------ |
| `target` | [`PluginDataTarget`](/api/expressive-code/core/type-aliases/plugindatatarget/) |
| `data` | `PluginDataType` |

