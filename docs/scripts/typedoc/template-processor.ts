import fs from 'node:fs'
import path from 'node:path'
import { parse } from 'yaml'

type IncludeDirective = {
	file: string
	headingLevel: number
	editSections?:
		| {
				path: string
				// Possible edits
				replaceWith?: string | undefined
				append?: string | undefined
		  }[]
		| undefined
	replacements?: { search: string; replace: string }[] | undefined
}

export function processTemplate({ apiDocsPath, templateFilePath, outputFilePath }: { apiDocsPath: string; templateFilePath: string; outputFilePath: string }) {
	console.log('Processing template:', templateFilePath)
	let markdown = fs.readFileSync(templateFilePath, 'utf8')
	markdown = markdown.replace(/````ya?ml include\n([\s\S]+?)\n````/g, (_, yaml: string) => {
		const directive = parse(yaml) as IncludeDirective
		if (!directive.file || !(directive.headingLevel > 1)) throw new Error(`Invalid template directive: ${yaml}`)
		const lines = fs.readFileSync(path.join(apiDocsPath, directive.file), 'utf8').split(/\r?\n/)
		// Change heading levels to match the template
		let headings = collectHeadings(lines)
		if (headings.length) {
			const headingLevelOffset = directive.headingLevel - headings[0]!.level
			headings.forEach((heading) => {
				heading.level = Math.max(1, heading.level + headingLevelOffset)
				lines[heading.lineIdx] = '#'.repeat(heading.level) + ' ' + heading.text
			})
		}

		directive.editSections?.forEach((edit) => {
			const headingIdx = headings.findIndex((h) => h.textPath === edit.path)
			const heading = headings[headingIdx]
			if (!heading)
				throw new Error(
					`No headings found for path "${edit.path}". Possible matches: ${headings
						.filter((h) => h.textPath.endsWith(edit.path))
						.map((h) => `"${h.textPath}"`)
						.join(', ')}?`
				)
			if (edit.replaceWith) {
				// Find the end line index of the section
				const nextSectionHeading = headings.slice(headingIdx + 1).find((h) => h.level <= heading.level)
				const sectionEndLineIdx = (nextSectionHeading?.lineIdx ?? lines.length) - 1
				// Replace the section contents
				lines.splice(heading.lineIdx + 1, sectionEndLineIdx - heading.lineIdx, '', ...edit.replaceWith.split(/\r?\n/))
				// Update the headings
				headings = collectHeadings(lines)
				return
			}
			if (edit.append) {
				// Find the line index of the next heading
				const nextHeading = headings[headingIdx + 1]
				const nextHeadingLineIdx = nextHeading?.lineIdx ?? lines.length
				// Insert the new lines before the next heading
				lines.splice(nextHeadingLineIdx, 0, ...edit.append.split(/\r?\n/))
				// Update the headings
				headings = collectHeadings(lines)
				return
			}
			throw new Error(`Unsupported edit section directive: ${JSON.stringify(edit)}`)
		})

		directive.replacements?.forEach((replacement) => {
			const regex = new RegExp(replacement.search, 'g')
			lines.forEach((line, lineIdx) => {
				lines[lineIdx] = line.replace(regex, replacement.replace)
			})
		})

		return lines.join('\n')
	})

	// Auto-import known components after frontmatter
	if (markdown.includes('<TypeProperties>')) {
		markdown = addAfterEndOfFrontmatter(markdown, `import TypeProperties from '@components/TypeProperties.astro'\n`)
	}

	// Add warning about auto-generated content
	markdown = markdown.replace(
		/^(---\n)/,
		`---
# WARNING: Do not edit this file directly, your changes will be overwritten!
# This file is auto-generated from a template inside "scripts/typedoc/templates".
		`.trim() + '\n'
	)

	fs.writeFileSync(outputFilePath, markdown)
}

function collectHeadings(lines: string[]) {
	// Get all markdown headings with their line indices
	const headings = lines
		.map((line, lineIdx) => ({
			lineIdx,
			level: (line.match(/^(#+) /)?.[1] ?? '').length,
			text: line.replace(/^(#+) /, ''),
			textPath: '',
		}))
		.filter((heading) => heading.level > 0)
	// Go through the headings and build a path of all higher-level headings leading up to each one
	const findParentHeading = (heading: (typeof headings)[0]) => {
		const headingIdx = headings.indexOf(heading)
		return headings.slice(0, headingIdx).findLast((h) => h.level < heading.level)
	}
	headings.forEach((heading) => {
		let parentHeading = findParentHeading(heading)
		let textPath = heading.text
		while (parentHeading) {
			textPath = parentHeading.text + '/' + textPath
			parentHeading = findParentHeading(parentHeading)
		}
		heading.textPath = textPath
	})
	return headings
}

function addAfterEndOfFrontmatter(markdown: string, addition: string) {
	return markdown.replace(/^(---\n[\s\S]+?\n---\n)/, `$1${addition}`)
}
